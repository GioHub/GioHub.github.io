<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>TTS Pro con Grabadora üéôÔ∏è</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f9fafb;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
    }
    .container {
      max-width: 650px;
      background: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      text-align: center;
    }
    textarea {
      width: 100%;
      height: 120px;
      margin-bottom: 15px;
      padding: 10px;
      font-size: 15px;
      border-radius: 8px;
      border: 1px solid #ccc;
      resize: none;
    }
    select, input[type=range] {
      width: 100%;
      margin: 8px 0;
    }
    button {
      margin: 8px;
      padding: 10px 16px;
      border-radius: 8px;
      border: none;
      font-size: 15px;
      cursor: pointer;
      color: white;
    }
    #playBtn { background: #2563eb; }
    #startBtn { background: #16a34a; }
    #stopBtn { background: #dc2626; }
    #stopBtn:disabled, #startBtn:disabled, #playBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    audio {
      margin-top: 15px;
      width: 100%;
      outline: none;
      display: none;
    }
    a {
      display: none;
      margin: 10px;
      color: #2563eb;
      text-decoration: none;
    }
    label {
      display: block;
      text-align: left;
      margin-top: 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Texto a Voz Pro üéôÔ∏è</h2>
    <textarea id="textInput" placeholder="Escribe tu texto aqu√≠...
Ejemplo: Hola [pause=2] mundo"></textarea>
    
    <label for="voiceSelect">Voz:</label>
    <select id="voiceSelect"></select>

    <label for="rateRange">Velocidad: <span id="rateValue">1</span>x</label>
    <input id="rateRange" type="range" min="0.5" max="2" step="0.1" value="1">

    <label for="pitchRange">Tono: <span id="pitchValue">1</span></label>
    <input id="pitchRange" type="range" min="0.5" max="2" step="0.1" value="1">

    <button id="playBtn">‚ñ∂ Reproducir Texto</button>
    <button id="startBtn">üî¥ Grabar Voz</button>
    <button id="stopBtn" disabled>‚èπ Detener</button>
    <br>
    <audio id="ttsAudio" controls></audio>
    <br>
    <audio id="audioPlayer" controls></audio>
    <br>
    <a id="downloadWebm" download="tts_grabacion.webm">‚¨á Descargar .webm</a>
    <a id="downloadWav" download="tts_grabacion.wav">‚¨á Descargar .wav</a>
  </div>

  <script>
    const textInput = document.getElementById("textInput");
    const playBtn = document.getElementById("playBtn");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const ttsAudio = document.getElementById("ttsAudio");
    const audioPlayer = document.getElementById("audioPlayer");
    const downloadWebm = document.getElementById("downloadWebm");
    const downloadWav = document.getElementById("downloadWav");
    const voiceSelect = document.getElementById("voiceSelect");
    const rateRange = document.getElementById("rateRange");
    const pitchRange = document.getElementById("pitchRange");
    const rateValue = document.getElementById("rateValue");
    const pitchValue = document.getElementById("pitchValue");

    // Contexto de audio y destino de grabaci√≥n
    const audioCtx = new AudioContext();
    const dest = audioCtx.createMediaStreamDestination();
    let mediaRecorder, audioChunks = [];

    // Enganchar <audio> al contexto
    const sourceNode = audioCtx.createMediaElementSource(ttsAudio);
    sourceNode.connect(audioCtx.destination);
    sourceNode.connect(dest);

    // ---- Manejo de voces ----
    let voices = [];
    function populateVoices() {
      voices = speechSynthesis.getVoices();
      voiceSelect.innerHTML = "";
      voices.forEach((voice, i) => {
        const option = document.createElement("option");
        option.value = i;
        option.textContent = `${voice.name} (${voice.lang})`;
        voiceSelect.appendChild(option);
      });
    }
    populateVoices();
    speechSynthesis.onvoiceschanged = populateVoices;

    // ---- Reproducir Texto con pausas ----
    function speakWithPauses(text, rate, pitch, voice) {
      // Dividir por [pause=n]
      const parts = text.split(/\[pause=(\d+(\.\d+)?)\]/);

      let index = 0;
      function processNext() {
        if (index >= parts.length) return;

        const chunk = parts[index];

        if (index % 3 === 0) {
          // Texto normal
          if (chunk.trim()) {
            const utterance = new SpeechSynthesisUtterance(chunk);
            utterance.rate = rate;
            utterance.pitch = pitch;
            if (voice) utterance.voice = voice;

            utterance.onend = () => {
              index++;
              processNext();
            };
            speechSynthesis.speak(utterance);
          } else {
            index++;
            processNext();
          }
        } else {
          // Pausa detectada
          const pauseSeconds = parseFloat(chunk);
          setTimeout(() => {
            index++;
            processNext();
          }, pauseSeconds * 1000);
        }
      }
      processNext();
    }

    playBtn.addEventListener("click", () => {
      const text = textInput.value.trim();
      if (!text) return alert("Escribe alg√∫n texto primero.");

      const rate = parseFloat(rateRange.value);
      const pitch = parseFloat(pitchRange.value);
      const selectedVoice = voices[voiceSelect.value];

      playBtn.disabled = true;
      speechSynthesis.cancel();

      speakWithPauses(text, rate, pitch, selectedVoice);

      // Rehabilitar bot√≥n al terminar todo (estimado)
      const estimatedDuration = text.split(" ").length / rate * 400;
      setTimeout(() => playBtn.disabled = false, estimatedDuration);
    });

    // ---- Grabaci√≥n ----
    startBtn.addEventListener("click", () => {
      mediaRecorder = new MediaRecorder(dest.stream, {
        mimeType: "audio/webm;codecs=opus"
      });
      audioChunks = [];

      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) audioChunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        const blobWebm = new Blob(audioChunks, { type: "audio/webm" });
        const urlWebm = URL.createObjectURL(blobWebm);

        audioPlayer.src = urlWebm;
        audioPlayer.style.display = "block";

        downloadWebm.href = urlWebm;
        downloadWebm.style.display = "inline-block";

        // Convertir a WAV
        try {
          const arrayBuffer = await blobWebm.arrayBuffer();
          const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
          const wavBlob = audioBufferToWav(audioBuffer);
          const urlWav = URL.createObjectURL(wavBlob);

          downloadWav.href = urlWav;
          downloadWav.style.display = "inline-block";
        } catch (err) {
          console.error("Error al convertir a WAV:", err);
        }
      };

      mediaRecorder.start();
      startBtn.disabled = true;
      stopBtn.disabled = false;
    });

    stopBtn.addEventListener("click", () => {
      mediaRecorder.stop();
      startBtn.disabled = false;
      stopBtn.disabled = true;
    });

    // ---- Actualizar valores UI ----
    rateRange.addEventListener("input", () => rateValue.textContent = rateRange.value);
    pitchRange.addEventListener("input", () => pitchValue.textContent = pitchRange.value);

    // ---- Conversi√≥n a WAV ----
    function audioBufferToWav(buffer) {
      const numOfChan = buffer.numberOfChannels,
            length = buffer.length * numOfChan * 2 + 44,
            bufferOut = new ArrayBuffer(length),
            view = new DataView(bufferOut),
            channels = [],
            sampleRate = buffer.sampleRate;
      let offset = 0;
      let pos = 0;

      setUint32(0x46464952); // "RIFF"
      setUint32(length - 8);
      setUint32(0x45564157); // "WAVE"

      setUint32(0x20746d66); // "fmt "
      setUint32(16);
      setUint16(1);
      setUint16(numOfChan);
      setUint32(sampleRate);
      setUint32(sampleRate * 2 * numOfChan);
      setUint16(numOfChan * 2);
      setUint16(16);

      setUint32(0x61746164); // "data"
      setUint32(length - pos - 4);

      for (let i = 0; i < buffer.numberOfChannels; i++)
        channels.push(buffer.getChannelData(i));

      while (pos < length) {
        for (let i = 0; i < numOfChan; i++) {
          const sample = Math.max(-1, Math.min(1, channels[i][offset]));
          const int16 = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(pos, int16, true);
          pos += 2;
        }
        offset++;
      }

      return new Blob([bufferOut], { type: "audio/wav" });

      function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
      function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
    }
  </script>
</body>
</html>
